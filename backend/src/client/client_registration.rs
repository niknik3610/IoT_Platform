use crate::client_registration::client_registration_service::registration_service_client::RegistrationServiceClient;
use std::time::Duration;

use rsa::{RsaPublicKey};
use tokio::time::sleep;

use crate::SERVER_IP;

use self::client_registration_service::{Capabilities, Capability, RegistrationRequest};

mod client_registration_service {
    tonic::include_proto!("iot.registration");
}

///Registers client with server, returns ID generated by server
//TODO: take in static array of Capability
pub async fn register_self(public_key: &RsaPublicKey) -> anyhow::Result<String> {
    let mut client = RegistrationServiceClient::connect(SERVER_IP).await?;
    let stringified_public_key: String = serde_json::to_string(public_key).unwrap();
    let response = client
        .register(RegistrationRequest {
            public_key: stringified_public_key,
            capabilities: vec![
                Capability {
                    available: true,
                    capability: Capabilities::TurnOn as i32,
                },
                Capability {
                    available: true,
                    capability: Capabilities::TurnOff as i32,
                },
            ],
        })
        .await?;

    let response = response.into_inner();
    let id = response.client_id;
    let certificate = response.certificate;
    println!("certificate: {certificate}");
    return Ok(id);
}

///Repeats the register_self operation until success
pub async fn repeated_register_self(public_key: &RsaPublicKey) -> String {
    let id = loop {
        let id_req_result = register_self(public_key).await;
        match id_req_result {
            Ok(r) => {
                break r;
            }
            Err(ref e) => {
                eprintln!("Error During ID request, trying again");
                eprintln!("{}", e.to_string());
                sleep(Duration::from_millis(500)).await;
            }
        }
    };

    return id;
}
